// Import standard library modules
const std: type = @import("std");
const Io: type = std.Io;
// Import AST module from root
const ast: type = @import("root").Ast;

const GENERATED_FILE_NOTICE: *const [298:0]u8 = (
    \\// ========================================================
    \\//  THIS FILE IS GENERATED BY JUPITERLANG COMPILER
    \\//  DO NOT EDIT MANUALLY!
    \\//  
    \\//  Any changes made directly to this file will be
    \\//  overwritten when the code is regenerated.
    \\// ========================================================
);

/// Code generator for converting AST to C++ code
/// This struct handles the translation of Jupiter language AST nodes
/// into equivalent C++ code with proper formatting and smart pointer handling
pub const CodeGen: type = struct {
    allocator: std.mem.Allocator, // Memory allocator for output buffer
    output: std.ArrayList(u8), // Buffer for generated C++ code
    indent_level: usize = 0, // Current indentation level for formatting

    /// Initialize a new CodeGen instance
    /// @param allocator Memory allocator for output buffer
    /// @return CodeGen instance
    pub fn init(allocator: std.mem.Allocator) CodeGen {
        return .{
            .allocator = allocator,
            .output = std.ArrayList(u8).empty,
        };
    }

    /// Generate C++ code from AST
    /// @param self CodeGen instance
    /// @param node Root AST node to generate code from
    /// @return Generated C++ code as string
    pub fn generate(self: *CodeGen, node: *ast.Node) anyerror![]const u8 {
        try self.generateNode(node);
        return self.output.items;
    }

    /// Dispatch to appropriate generator based on node type
    /// @param self CodeGen instance
    /// @param node AST node to generate code for
    fn generateNode(self: *CodeGen, node: *ast.Node) anyerror!void {
        switch (node.type) {
            .program => try self.generateProgram(node),
            .import_decl => try self.generateImport(node),
            .function_decl => try self.generateFunction(node),
            .struct_decl => try self.generateStruct(node),
            .variable_decl => try self.generateVariableDecl(node),
            .return_stmt => try self.generateReturn(node),
            .call_expr => try self.generateCallExpr(node),
            .binary_expr => try self.generateBinaryExpr(node),
            .literal_expr => try self.generateLiteral(node),
            .identifier_expr => try self.generateIdentifier(node),
            .if_stmt => try self.generateIf(node),
            .while_loop => try self.generateWhile(node),
            .member_access => try self.generateMemberAccess(node),
        }
    }

    /// Generate C++ code for program node
    /// @param self CodeGen instance
    /// @param node Program AST node
    fn generateProgram(self: *CodeGen, node: *ast.Node) anyerror!void {
        try self.writeln(GENERATED_FILE_NOTICE, .{});

        // Generate imports
        for (node.data.program.imports.items) |import_node| {
            try self.generateNode(import_node);
        }

        // Generate structs
        for (node.data.program.structs.items) |struct_node| {
            try self.generateNode(struct_node);
            try self.writeln("", .{});
        }

        // Generate functions
        for (node.data.program.functions.items) |func_node| {
            try self.generateNode(func_node);
            try self.writeln("", .{});
        }
    }

    /// Generate C++ include statement for import node
    /// @param self CodeGen instance
    /// @param node Import AST node
    fn generateImport(self: *CodeGen, node: *ast.Node) anyerror!void {
        const path: []const u8 = node.data.import_decl.path;
        std.debug.print("{s}", .{path});
        if (std.mem.startsWith(u8, path, "<") and std.mem.endsWith(u8, path, ">")) {
            try self.writeln("#include {s}", .{path});
        } else {
            try self.writeln("#include \"{s}\"", .{path});
        }
    }

    /// Generate C++ function declaration
    /// @param self CodeGen instance
    /// @param node Function declaration AST node
    fn generateFunction(self: *CodeGen, node: *ast.Node) anyerror!void {
        const func = node.data.function_decl;

        // Convert return type
        const return_type: []const u8 = try self.convertType(func.return_type);

        // Special handling for main function
        if (std.mem.eql(u8, func.name, "main")) {
            try self.writeln("int main() {{", .{});
        } else {
            try self.write("{s} {s}(", .{ return_type, func.name });

            // Parameters
            for (func.params.items, 0..) |param, i| {
                if (i > 0) {
                    try self.write(", ", .{});
                }
                const param_type = try self.convertType(param.param_type);
                try self.write("{s} {s}", .{ param_type, param.name });
            }

            try self.writeln(") {{", .{});
        }

        self.indent_level += 1;

        // Function body
        for (func.body.items) |stmt| {
            try self.generateNode(stmt);
        }

        self.indent_level -= 1;
        try self.writeln("}}", .{});
    }

    /// Generate C++ struct declaration
    /// @param self CodeGen instance
    /// @param node Struct declaration AST node
    fn generateStruct(self: *CodeGen, node: *ast.Node) anyerror!void {
        const struct_decl = node.data.struct_decl;
        try self.writeln("struct {s} {{", .{struct_decl.name});

        self.indent_level += 1;

        // Fields
        for (struct_decl.fields.items) |field| {
            const field_type: []const u8 = try self.convertType(field.field_type);
            try self.writeln("{s} {s};", .{ field_type, field.name });
        }

        self.indent_level -= 1;
        try self.writeln("}};", .{});
    }

    /// Generate C++ variable declaration
    /// @param self CodeGen instance
    /// @param node Variable declaration AST node
    fn generateVariableDecl(self: *CodeGen, node: *ast.Node) anyerror!void {
        const var_decl = node.data.variable_decl;
        try self.indent();

        if (var_decl.var_type) |var_type| {
            const cpp_type = try self.convertType(var_type);

            // Check if it's a smart pointer
            if (var_type.is_pointer) {
                if (std.mem.eql(u8, var_type.name, "Box")) {
                    try self.write("unique_ptr<", .{});
                    // Extract inner type from Box<T>
                    if (var_decl.value) |value| {
                        _ = value;
                        // Here we would need to infer the type of the value
                        try self.write("auto", .{});
                    } else {
                        try self.write("void", .{}); // Fallback
                    }
                    try self.write(">", .{});
                } else if (std.mem.eql(u8, var_type.name, "Shared")) {
                    try self.write("shared_ptr<auto>", .{});
                } else {
                    try self.write("{s}*", .{cpp_type});
                }
            } else {
                try self.write("{s}", .{cpp_type});
            }

            try self.write(" {s} = ", .{var_decl.name});
        } else {
            // Type inference
            try self.write("auto {s} = ", .{var_decl.name});
        }

        if (var_decl.value) |value| {
            try self.generateNode(value);
        }

        try self.writeln(";", .{});
    }

    /// Generate C++ return statement
    /// @param self CodeGen instance
    /// @param node Return statement AST node
    fn generateReturn(self: *CodeGen, node: *ast.Node) anyerror!void {
        const return_stmt = node.data.return_stmt;
        try self.indent();
        try self.write("return", .{});

        if (return_stmt.value) |value| {
            try self.write(" ", .{});
            try self.generateNode(value);
        }

        try self.writeln(";", .{});
    }

    /// Generate C++ function call expression
    /// @param self CodeGen instance
    /// @param node Function call AST node
    fn generateCallExpr(self: *CodeGen, node: *ast.Node) anyerror!void {
        const call_expr = node.data.call_expr;
        try self.generateNode(call_expr.callee);
        try self.write("(", .{});

        for (call_expr.args.items, 0..) |arg, i| {
            if (i > 0) try self.write(", ", .{});
            try self.generateNode(arg);
        }

        try self.write(")", .{});
    }

    /// Generate C++ binary expression
    /// @param self CodeGen instance
    /// @param node Binary expression AST node
    fn generateBinaryExpr(self: *CodeGen, node: *ast.Node) anyerror!void {
        const bin_expr = node.data.binary_expr;

        // Assignment operator for smart pointers
        if (std.mem.eql(u8, bin_expr.operator, "=") and
            bin_expr.left.type == .identifier_expr)
        {
            const left_name = bin_expr.left.data.identifier.name;

            _ = left_name;
            // Check if it's a Box/Shared creation
            if (bin_expr.right.type == .call_expr) {
                const right_call = bin_expr.right.data.call_expr;
                if (right_call.callee.type == .identifier_expr) {
                    const callee_name = right_call.callee.data.identifier.name;

                    if (std.mem.eql(u8, callee_name, "Box")) {
                        try self.write("make_unique<", .{});
                        if (right_call.args.items.len > 0) {
                            try self.generateNode(right_call.args.items[0]);
                        } else {
                            try self.write("void", .{});
                        }
                        try self.write(">()", .{});
                        return;
                    } else if (std.mem.eql(u8, callee_name, "Shared")) {
                        try self.write("make_shared<", .{});
                        if (right_call.args.items.len > 0) {
                            try self.generateNode(right_call.args.items[0]);
                        } else {
                            try self.write("void", .{});
                        }
                        try self.write(">()", .{});
                        return;
                    }
                }
            }
        }

        try self.generateNode(bin_expr.left);
        try self.write(" {s} ", .{bin_expr.operator});
        try self.generateNode(bin_expr.right);
    }

    /// Generate C++ literal expression
    /// @param self CodeGen instance
    /// @param node Literal expression AST node
    fn generateLiteral(self: *CodeGen, node: *ast.Node) anyerror!void {
        const literal = node.data.literal;
        switch (literal.literal_type) {
            .string_literal => {
                // Remove quotes and add std::string if necessary
                const value = std.mem.trim(u8, literal.value, "\"");
                try self.write("std::string(\"{s}\")", .{value});
            },
            .bool_literal => {
                try self.write("{s}", .{literal.value});
            },
            else => {
                try self.write("{s}", .{literal.value});
            },
        }
    }

    /// Generate C++ identifier expression
    /// @param self CodeGen instance
    /// @param node Identifier expression AST node
    fn generateIdentifier(self: *CodeGen, node: *ast.Node) anyerror!void {
        try self.write("{s}", .{node.data.identifier.name});
    }

    /// Generate C++ member access expression
    /// @param self CodeGen instance
    /// @param node Member access AST node
    fn generateMemberAccess(self: *CodeGen, node: *ast.Node) anyerror!void {
        const member_access = node.data.member_access;
        try self.generateNode(member_access.object);
        try self.write(".{s}", .{member_access.member});
    }

    /// Generate C++ if statement
    /// @param self CodeGen instance
    /// @param node If statement AST node
    fn generateIf(self: *CodeGen, node: *ast.Node) anyerror!void {
        const if_stmt = node.data.if_stmt;
        try self.indent();
        try self.write("if (", .{});
        try self.generateNode(if_stmt.condition);
        try self.writeln(") {{", .{});

        self.indent_level += 1;
        for (if_stmt.then_branch.items) |stmt| {
            try self.generateNode(stmt);
        }
        self.indent_level -= 1;

        if (if_stmt.else_branch.items.len > 0) {
            try self.indent();
            try self.writeln("}} else {{", .{});
            self.indent_level += 1;
            for (if_stmt.else_branch.items) |stmt| {
                try self.generateNode(stmt);
            }
            self.indent_level -= 1;
        }

        try self.indent();
        try self.writeln("}}", .{});
    }

    /// Generate C++ while loop
    /// @param self CodeGen instance
    /// @param node While loop AST node
    fn generateWhile(self: *CodeGen, node: *ast.Node) anyerror!void {
        const while_loop = node.data.while_loop;
        try self.indent();
        try self.write("while (", .{});
        try self.generateNode(while_loop.condition);
        try self.writeln(") {{", .{});

        self.indent_level += 1;
        for (while_loop.body.items) |stmt| {
            try self.generateNode(stmt);
        }
        self.indent_level -= 1;

        try self.indent();
        try self.writeln("}}", .{});
    }

    /// Convert Jupiter type to C++ type
    /// @param self CodeGen instance
    /// @param jupiter_type Jupiter type to convert
    /// @return Equivalent C++ type name
    fn convertType(self: *CodeGen, jupiter_type: ast.Type) anyerror![]const u8 {
        _ = self;
        const type_name = jupiter_type.name;

        // Map basic types
        if (std.mem.eql(u8, type_name, "int")) {
            return "int";
        }
        if (std.mem.eql(u8, type_name, "string")) {
            return "std::string";
        }
        if (std.mem.eql(u8, type_name, "bool")) {
            return "bool";
        }
        if (std.mem.eql(u8, type_name, "float")) {
            return "float";
        }
        if (std.mem.eql(u8, type_name, "void")) {
            return "void";
        }

        // Smart pointers
        if (std.mem.eql(u8, type_name, "Box")) {
            return "std::unique_ptr"; // Inner type will be resolved later
        }
        if (std.mem.eql(u8, type_name, "Shared")) {
            return "std::shared_ptr";
        }

        return type_name; // User-defined types
    }

    /// Write indentation to output
    /// @param self CodeGen instance
    fn indent(self: *CodeGen) anyerror!void {
        for (0..self.indent_level) |_| {
            try self.output.appendSlice(self.allocator, "    ");
        }
    }

    /// Write formatted string to output
    /// @param self CodeGen instance
    /// @param format Format string
    /// @param args Format arguments
    fn write(self: *CodeGen, comptime format: []const u8, args: anytype) anyerror!void {
        const s = try std.fmt.allocPrint(self.allocator, format, args);
        defer self.allocator.free(s);
        try self.output.appendSlice(self.allocator, s);
    }

    /// Write formatted string with newline to output
    /// @param self CodeGen instance
    /// @param format Format string
    /// @param args Format arguments
    fn writeln(self: *CodeGen, comptime format: []const u8, args: anytype) anyerror!void {
        try self.write(format, args);
        try self.output.append(self.allocator, '\n');
    }
};
